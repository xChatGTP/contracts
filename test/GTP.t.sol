// SPDX-License-Identifier: MIT
pragma solidity ^0.8.15;

import { IERC20 } from 'oz/token/ERC20/IERC20.sol';
import { console } from 'forge-std/console.sol';
import 'forge-std/Test.sol';

import { Tokens } from '../script/utils/Tokens.sol';
import { DeployHUniswapV3 } from '../script/handlers/HUniswapV3.s.sol';
import { GTP } from '../src/GTP.sol';
import { HUniswapV3 } from '../src/handlers/uniswapv3/HUniswapV3.sol';
import { HFunds } from '../src/handlers/funds/HFunds.sol';

interface IWrappedNativeToken {
	function deposit() external payable;
	function withdraw(uint256 wad) external;
}

contract GTPTest is Test {
	GTP internal gtp;
	HUniswapV3 internal hUniswapV3;
	HFunds internal hFunds;

	address internal wNativeToken;
	address internal swapRouter;

	address internal gateway;
	address internal gasReceiver;

	function setUp() public {
		Tokens tokens = new Tokens();
		DeployHUniswapV3 dhuniv3 = new DeployHUniswapV3();
    
		wNativeToken = tokens.getWrappedNativeToken();
		swapRouter = dhuniv3.getSwapRouter();

		gateway = tokens.getAxelarGateway();
		gasReceiver = tokens.getAxelarGasService();

		gtp = new GTP(
				gateway, // gateway
				gasReceiver, // gasReceiver
				tokens.getAxelarNativeTokenSymbol(), // native token symbol
				wNativeToken // native token
		);

		IERC20(wNativeToken).approve(address(gtp), type(uint256).max);

		hUniswapV3 = new HUniswapV3(wNativeToken, swapRouter);
		hFunds = new HFunds();

		// Get Wrapped Token
		vm.deal(address(this), 10_000 ether);
		require(address(this).balance >= 10_000 ether, 'Not enough balance');
		IWrappedNativeToken(wNativeToken).deposit{value: 100 ether}();

		// Get WETH on Polygon Mumbai
		vm.prank(0x9883D5e7dC023A441A01Ef95aF406C69926a0AB6);
		IERC20(0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa).transfer(
			address(this),
			50 ether
		);
		vm.prank(0x9883D5e7dC023A441A01Ef95aF406C69926a0AB6);
		IERC20(0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa).transfer(
			address(gtp),
			50 ether
		);
		IERC20(0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa).approve(
			address(gtp),
			type(uint256).max
		);

	}

	function testEmpty() public {
		address[] memory tos = new address[](0);
		bytes32[] memory configs = new bytes32[](0);
		bytes[] memory datas = new bytes[](0);

		gtp.batchExec(tos, configs, datas);
	}

	function testInvalidLength() public {
		address[] memory tos = new address[](1);
		bytes32[] memory configs = new bytes32[](0);
		bytes[] memory datas = new bytes[](0);

		tos[0] = address(hFunds);

		console.log(tos[0]);
		gtp.batchExec(tos, configs, datas);
	}

	function testInject() public {
		address[] memory tos = new address[](1);
		bytes32[] memory configs = new bytes32[](1);
		bytes[] memory datas = new bytes[](1);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[0] = hex'd0797f840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000d500B1d8E8eF31E21C99d1Db9A6444d3ADf127000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000';

		gtp.batchExec{ value: 1 ether }(tos, configs, datas);
	}

	function testSwapNative2Token() public {
		console.log('matic bal (this)', address(this).balance);
		console.log('matic bal (GTP)', address(gtp).balance);
		console.log('usdc bal (this)', IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).balanceOf(address(this)));
		console.log('usdc bal (GTP)', IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).balanceOf(address(gtp)));

		address[] memory tos = new address[](2);
		bytes32[] memory configs = new bytes32[](2);
		bytes[] memory datas = new bytes[](2);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[0] = hex'd0797f840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000d500B1d8E8eF31E21C99d1Db9A6444d3ADf127000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000';

		tos[1] = address(hUniswapV3);
		configs[1] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[1] = hex'8aa5b89b0000000000000000000000002791Bca1f2de4661ED88A30C99A7a9449Aa8417400000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000';

		gtp.batchExec{ value: 1 ether }(tos, configs, datas);

		console.log('matic bal (this)', address(this).balance);
		console.log('matic bal (GTP)', address(gtp).balance);
		console.log('usdc bal (this)', IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).balanceOf(address(this)));
		console.log('usdc bal (GTP)', IERC20(0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174).balanceOf(address(gtp)));
	}

	function testBridge() public {
		address[] memory tos = new address[](2);
		bytes32[] memory configs = new bytes32[](2);
		bytes[] memory datas = new bytes[](2);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[0] = hex'd0797f840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000009c3C9283D3e44854697Cd22D3Faa240Cfb03288900000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000';

		tos[1] = address(0);
		configs[1] = 0x0100000000000000000100ffffffffffffffffffffffffffffffffffffffffff;
		datas[1] = hex'00000000000138810000A8699c3C9283D3e44854697Cd22D3Faa240Cfb032889';

		gtp.batchExec{ value: 1 ether }(tos, configs, datas);
	}

	function testSwapNBridge() public {
		address[] memory tos = new address[](3);
		bytes32[] memory configs = new bytes32[](3);
		bytes[] memory datas = new bytes[](3);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		// HFunds inject 1 ether WETH
		datas[0] = hex'd0797f84000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000A6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000009184e72a000';

		tos[1] = address(hUniswapV3);
		configs[1] = 0x0001000000000000000000000000000000000000000000000000000000000000;
		datas[1] = hex'e473efd3000000000000000000000000A6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa0000000000000000000000000000000000000000000000000000000000000064000000000000000000000000000000000000000000000000000009184e72a00000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000';

		tos[2] = address(0);
		configs[2] = 0x0100000000000000000100ffffffffffffffffffffffffffffffffffffffffff;
		datas[2] = hex'00000000000138810000A8699c3C9283D3e44854697Cd22D3Faa240Cfb032889';

		gtp.batchExec{ value: 1 ether }(tos, configs, datas);
	}

	function testUnpack() public {
		bytes memory payload = hex'00000000000000000000000006edd6f25b8e73b4800a3a31c89e2fa81dc8b3bf000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000001400000000000000000000000000000000000000000000000000000000000000002000000000000000000000000bd1869806cf43d90589d27d28af5edcb3c84fff4000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020100000000000000000200ffffffffffffffffffffffffffffffffffffffffff00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000006418248f2a000000000000000000000000de3db4fd7d7a5cc7d8811b7bafa4103fd90282f3000000000000000000000000000000000000000000000000000000e8d4a5100000000000000000000000000006edd6f25b8e73b4800a3a31c89e2fa81dc8b3bf000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000';

		address user;
		address[] memory tos;
		bytes32[] memory configs;
		bytes[] memory datas;
		
		(user, tos, configs, datas) = abi.decode(payload, (address, address[], bytes32[], bytes[]));
		console.log(user);
		console.log(tos[0]);
		console.logBytes32(configs[0]);
		console.logBytes(datas[0]);
	}

	function testSend() public {
		address[] memory tos = new address[](2);
		bytes32[] memory configs = new bytes32[](2);
		bytes[] memory datas = new bytes[](2);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[0] = hex'd0797f840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000009c3C9283D3e44854697Cd22D3Faa240Cfb03288900000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000de0b6b3a7640000';

		// Send Mumbai WMATIC
		tos[1] = address(hFunds);
		configs[1] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[1] = hex'18248f2a0000000000000000000000009c3C9283D3e44854697Cd22D3Faa240Cfb032889000000000000000000000000000000000000000000000000000000E8D4A5100000000000000000000000000006Edd6F25B8e73B4800A3a31C89E2fa81dC8b3BF';

		gtp.batchExec{ value: 1 ether }(tos, configs, datas);
	}

	function testSwapNSend() public {
		address[] memory tos = new address[](3);
		bytes32[] memory configs = new bytes32[](3);
		bytes[] memory datas = new bytes[](3);

		tos[0] = address(hFunds);
		configs[0] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		// HFunds inject 1 ether WETH
		datas[0] = hex'd0797f840000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000009c3C9283D3e44854697Cd22D3Faa240Cfb032889000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000038d7ea4c68000';

		tos[1] = address(hUniswapV3);
		configs[1] = 0x0001000000000000000000000000000000000000000000000000000000000000;
		datas[1] = hex'8aa5b89b000000000000000000000000A6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa000000000000000000000000000000000000000000000000000000000000006400000000000000000000000000000000000000000000000000038d7ea4c6800000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000';

		tos[2] = address(hFunds);
		configs[2] = 0x0000000000000000000000000000000000000000000000000000000000000000;
		datas[2] = hex'18248f2a000000000000000000000000A6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa115792089237316195423570985008687907853269984665640564039457584007913129639935000000000000000000000000ab3f459de154B9D58DE8AdA4b4AEe271823c3155';

		gtp.batchExec(tos, configs, datas);
	}

	fallback() external payable {}
	receive() external payable {}
}